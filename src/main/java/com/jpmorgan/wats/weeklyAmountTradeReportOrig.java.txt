package com.jpmorgan.wats;


public class WeeklyAmountTradeReportOrig {


	public WeeklyAmountTradeReport() {}



	public void run()  {


		try {


			// Will get the file from the resources folder in Maven
			File csvFile = new File( this.getClass().getResource("/weeklyTradeData.csv").toURI() );

			CsvMapper mapper = new CsvMapper();
			//mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);


			CsvSchema schema = CsvSchema.emptySchema().withHeader();

			MappingIterator<Trade> mappedTrades = mapper.readerFor( Trade.class ).with( schema ).readValues( csvFile );
			
			List<Trade> trades = mappedTrades.readAll();


			//Comparator<Trade> tradeComparator = ( Trade trade1, Trade trade2 ) -> { return Comparator.comparing( Trade::getSettlementDay ).thenComparing( Trade::getTradeAmount ).compare( trade1, trade2 ); };
			Comparator<Trade> tradeComparator = Comparator.comparing( Trade::getEntity ).thenComparing( Trade::getTradeAmount );


			// Setting the Trade Amount on each trade as this not mapped in from CSV
			/*for ( Trade trade: trades ) {
				trade.setTradeAmount( trade.getPricePerUnit() * trade.getUnits() * trade.getAgreedFx() );
			}*/

			// *STREAM* Approach to updating each Trade with the TradeAmount value...
			List<Trade> updatedTrades = trades.stream().map( t -> {
				t.setTradeAmount( t.getPricePerUnit() * t.getUnits() * t.getAgreedFx() );
				return t;
			} ).collect( Collectors.toList() );  


			Collections.sort( trades, tradeComparator );

			for ( Trade trade: trades ) {
				System.out.println( trade );
			} 
			
			// *** FILTER THE MAPPED LIST INTO TWO LISTS => 1 CONTAINING BUY TRADES AND 1 CONTAINING SELL TRADES...

			System.out.println("-> BUY TRADES : ");
//			List<Trade> buyTrades = trades.stream().filter( t -> "B".equals( t.getBuyOrSell() ) ).collect( Collectors.toList());

			List<Trade> buyTrades = trades.stream()
						.filter( t -> "B".equals( t.getBuyOrSell() ) && this.validateSettlementDate( t.getSettlementDate() ) )
						.map( t -> {
							t.setSettlementDay( t.getSettlementDate().getDayOfWeek() );
							return t;
						} )
						.collect( Collectors.toList());

			buyTrades.forEach( System.out::println );


			System.out.println("-> SELL TRADES : ");
/*			List<Trade> sellTrades = trades.stream().filter( t -> "S".equals( t.getBuyOrSell() ) ).collect( Collectors.toList());
			sellTrades.forEach( System.out::println );
*/
/*			List<Trade> sellTrades = trades.stream()
						.filter( t -> "S".equals( t.getBuyOrSell() ) && this.validateSettlementDate( t.getSettlementDate() )  )
						.collect( Collectors.toList() );
*/
			List<Trade> sellTrades = trades.stream()
						.filter( t -> "S".equals( t.getBuyOrSell() ) && this.validateSettlementDate( t.getSettlementDate() )  )
						.map( t -> {
							t.setSettlementDay( t.getSettlementDate().getDayOfWeek() );
							return t;
						} )
						.collect( Collectors.toList() );


			sellTrades.forEach( System.out::println );




			// *** AT THE POINT NOW WHERE WORK NEEDS TO BE DONE ON THE DATES CONTAINED IN EACH TRADE TO FIGURE WHICH IS WITH REPORT RANGE...
/*			SET THE START DATE  (SUNDAY OF WEEK)
			SET THE END DATE  (FRIDAY OF WEEK)
				-> THERE ARE 2 WORKING WEEKS DEPENDING ON THE CURRENCY BEING USED...JUST SET IT UP FOR STANDARD WORKING WEEK FIRST TO GET DATE RANGES AND SETTLEMENT DAYS WORKING SO CAN REPORT ON THAT...
			CAN MAKE THE START AND END DATES MANUAL FOR THIS...
*/


		} catch ( Exception e ) {
			e.printStackTrace();
		}

	}	// End of method run()...


	private boolean validateSettlementDate( LocalDate settlementDate ) {
		// System.out.println( checkDate +  " is within range ? " + ( checkDate.isAfter( sunday ) || checkDate.isEqual( sunday ) ) );

		LocalDate weekStartDate = this.getCurrentWeekStartDate();
		LocalDate weekEndDate = this.getCurrentWeekEndDate();

		if ( ( settlementDate.isAfter( weekStartDate ) || settlementDate.isEqual( weekStartDate ) ) 
				&& ( settlementDate.isBefore( weekEndDate ) || settlementDate.isEqual( weekEndDate ) )  ) {
			return true;
		}
		return false;

	}	// End of method validateSettlementDate()...

	private LocalDate getCurrentWeekStartDate() {
        
        LocalDate today = LocalDate.now();

        LocalDate sunday = today;
        while ( sunday.getDayOfWeek() != DayOfWeek.SUNDAY ) {
        	sunday = sunday.minusDays(1);
        }
        return sunday;
	}

	private LocalDate getCurrentWeekEndDate() {

        LocalDate today = LocalDate.now();

        LocalDate friday = today;
        while ( friday.getDayOfWeek() != DayOfWeek.FRIDAY ) {
        	friday = friday.plusDays(1);
        }
        return friday;
	}
/*
        //NOW THAT HAVE BOTH DATES - CAN USE THEM TO CHECK A DATE IS WITH DATERANGE...
		LocalDate today = LocalDate.now();
        System.out.println( "Today is within range ? " + ( today.isBefore( friday ) || today.isEqual( friday ) ) );

        LocalDate checkDate = today.minusDays(7);
        System.out.println( checkDate +  " is within range ? " + ( checkDate.isAfter( sunday ) || checkDate.isEqual( sunday ) ) );


*/


}